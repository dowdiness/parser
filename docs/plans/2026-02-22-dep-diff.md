# Dependency Diff in force_recompute Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Diff old vs. new dependency lists in `Memo::force_recompute` to skip `compute_durability` when deps are stable, and leave Phase 4 subscriber hooks clearly marked.

**Architecture:** Extend `Runtime::pop_tracking` to return the `ActiveQuery`'s existing `HashSet[CellId]` alongside the dep array (zero extra allocation). In `force_recompute`, capture `old_deps` before computation, then walk old deps against `new_seen` to detect changes; skip `compute_durability` on the stable path.

**Tech Stack:** MoonBit. `moon test` runs tests. `moon check` type-checks. All source is in the root directory of `dowdiness/incr`.

---

### Background: how the code works

`Memo::force_recompute` (in `memo.mbt`) currently:
1. Calls `push_tracking` to start recording deps
2. Runs the compute function (which calls `Signal::get` / `Memo::get`, each recording a dep)
3. Calls `pop_tracking()` → returns `Array[CellId]` (the new dep list)
4. **Replaces** `cell.dependencies = new_deps` unconditionally
5. **Always** calls `compute_durability(self.rt, new_deps)` — an O(n) scan

`ActiveQuery` (in `tracking.mbt`) builds a `HashSet[CellId]` called `seen` for O(1) deduplication. Currently `pop_tracking` discards `seen`.

The plan:
- `pop_tracking` returns `(Array[CellId], @hashset.HashSet[CellId])` (deps + seen)
- `force_recompute` captures `old_deps`, unpacks `(new_deps, new_seen)`, checks if any old dep is absent from `new_seen` or counts differ → `deps_changed`
- Only calls `compute_durability` when `deps_changed`
- Adds Phase 4 comments for subscriber unsubscription

MoonBit conventions:
- Tests: `///|` on its own line above every `test "name" { ... }` block
- Assertions: `inspect(expr, content="expected_string")`
- Whitebox tests (`*_wbtest.mbt`): same package as source, can access private fields via `rt.get_cell(id).field`
- Run a single file: `moon test -p dowdiness/incr -f filename.mbt`
- Run all tests: `moon test`

---

### Task 1: Write whitebox tests documenting expected dep-tracking behavior

These tests document behaviour that must hold both before and after the change. They also act as a safety net: any bug in the new `force_recompute` logic that corrupts dep tracking or durability computation will be caught here.

**Files:**
- Create: `memo_dep_diff_wbtest.mbt`

**Step 1: Create the file with two tests**

Write `/home/antisatori/ghq/github.com/dowdiness/incr/memo_dep_diff_wbtest.mbt` with this exact content:

```moonbit
///|
// When a memo has stable dependencies (same cells read every recompute),
// its durability must be preserved correctly across multiple recomputations.
test "dep diff: stable deps preserve durability" {
  let rt = Runtime::new()
  let a = Signal::new(rt, 1, durability=High)
  let m = Memo::new(rt, () => a.get() + 1)
  let _ = m.get()
  let meta = rt.get_cell(m.id())
  inspect(meta.durability, content="High")
  // a changes value but dep list stays [a] — durability must stay High
  a.set(2)
  let _ = m.get()
  inspect(meta.durability, content="High")
  inspect(meta.dependencies.length(), content="1")
}

///|
// When a conditional memo switches which signal it reads, the dependency
// list and durability must both reflect the new set of dependencies.
test "dep diff: dynamic deps update dep list and durability" {
  let rt = Runtime::new()
  let flag = Signal::new(rt, true, durability=High)
  let a = Signal::new(rt, 1, durability=High)
  let b = Signal::new(rt, 2, durability=Low)
  let m = Memo::new(rt, () => {
    if flag.get() { a.get() } else { b.get() }
  })
  // Initial: reads flag(High) and a(High) → min durability = High
  let _ = m.get()
  let meta = rt.get_cell(m.id())
  inspect(meta.durability, content="High")
  inspect(meta.dependencies.length(), content="2")
  // Switch: reads flag(High) and b(Low) → min durability = Low
  flag.set(false)
  let _ = m.get()
  inspect(meta.durability, content="Low")
  inspect(meta.dependencies.length(), content="2")
}
```

**Step 2: Run to verify both tests currently pass**

```bash
cd /home/antisatori/ghq/github.com/dowdiness/incr && moon test -p dowdiness/incr -f memo_dep_diff_wbtest.mbt 2>&1
```

Expected output: `Total tests: 2, passed: 2, failed: 0.`

If a test fails here, stop — there is a pre-existing bug. Do not proceed until both pass.

---

### Task 2: Update `pop_tracking` to return the `seen` HashSet

**Files:**
- Modify: `runtime.mbt` (the `pop_tracking` function)

**Step 1: Find the current implementation**

The function is at approximately line 465 in `runtime.mbt` and looks like:

```moonbit
fn Runtime::pop_tracking(self : Runtime) -> Array[CellId] {
  match self.tracking_stack.pop() {
    Some(query) => query.dependencies
    None => abort("Tracking stack underflow")
  }
}
```

**Step 2: Replace it with the new version**

```moonbit
fn Runtime::pop_tracking(self : Runtime) -> (Array[CellId], @hashset.HashSet[CellId]) {
  match self.tracking_stack.pop() {
    Some(query) => (query.dependencies, query.seen)
    None => abort("Tracking stack underflow")
  }
}
```

**Step 3: Type-check (this will fail because `force_recompute` still destructures the old return type)**

```bash
cd /home/antisatori/ghq/github.com/dowdiness/incr && moon check 2>&1
```

Expected: a type error in `memo.mbt` at the `pop_tracking` call site — something like "expected `Array[CellId]`, got `(Array[CellId], HashSet[CellId])`". This is correct and expected at this step.

---

### Task 3: Update `force_recompute` to use the diff

**Files:**
- Modify: `memo.mbt` (the `force_recompute` function, approximately lines 162–188)

**Step 1: Find the current implementation**

```moonbit
fn[T : Eq] Memo::force_recompute(self : Memo[T]) -> Result[Unit, CycleError] {
  let cell = self.rt.get_cell(self.cell_id)
  if cell.in_progress {
    return Err(CycleError::from_path(self.rt.collect_tracking_path(), cell.id))
  }
  cell.in_progress = true
  // Push tracking frame to record dependencies
  self.rt.push_tracking(self.cell_id)
  let new_value = (self.compute)()
  let new_deps = self.rt.pop_tracking()
  cell.dependencies = new_deps
  // Update durability: max of all dependencies' durabilities
  cell.durability = compute_durability(self.rt, new_deps)
  // Backdating: if value unchanged, keep old changed_at
  let value_changed = match self.value {
    None => true
    Some(old) => old != new_value
  }
  self.value = Some(new_value)
  if value_changed {
    cell.changed_at = self.rt.current_revision
  }
  // else: backdate — keep old changed_at (key Salsa insight)
  cell.verified_at = self.rt.current_revision
  cell.in_progress = false
  Ok(())
}
```

**Step 2: Replace it with the diffing version**

```moonbit
fn[T : Eq] Memo::force_recompute(self : Memo[T]) -> Result[Unit, CycleError] {
  let cell = self.rt.get_cell(self.cell_id)
  if cell.in_progress {
    return Err(CycleError::from_path(self.rt.collect_tracking_path(), cell.id))
  }
  cell.in_progress = true
  let old_deps = cell.dependencies
  // Push tracking frame to record dependencies
  self.rt.push_tracking(self.cell_id)
  let new_value = (self.compute)()
  let (new_deps, new_seen) = self.rt.pop_tracking()
  // Diff: check whether the dep set changed.
  // new_seen is the HashSet already built by ActiveQuery — no extra allocation.
  // We walk old_deps and check membership in new_seen; a length mismatch is a
  // fast-path indicator of change (avoids the loop when counts differ).
  let mut deps_changed = new_deps.length() != old_deps.length()
  for dep in old_deps {
    if not(new_seen.contains(dep)) {
      deps_changed = true
    }
  }
  // Phase 4: removed = old_deps.filter(d => not(new_seen.contains(d)))
  // Phase 4: unsubscribe self.cell_id from each removed dep's subscriber list
  cell.dependencies = new_deps
  // Update durability only when the dep set changed (skip rescan on stable path)
  if deps_changed {
    cell.durability = compute_durability(self.rt, new_deps)
  }
  // Backdating: if value unchanged, keep old changed_at
  let value_changed = match self.value {
    None => true
    Some(old) => old != new_value
  }
  self.value = Some(new_value)
  if value_changed {
    cell.changed_at = self.rt.current_revision
  }
  // else: backdate — keep old changed_at (key Salsa insight)
  cell.verified_at = self.rt.current_revision
  cell.in_progress = false
  Ok(())
}
```

**Step 3: Type-check**

```bash
cd /home/antisatori/ghq/github.com/dowdiness/incr && moon check 2>&1
```

Expected: `Finished. moon: ran 3 tasks, now up to date` — no errors.

---

### Task 4: Run all tests

```bash
cd /home/antisatori/ghq/github.com/dowdiness/incr && moon test 2>&1
```

Expected: all tests pass (140+ tests). If anything fails, stop and investigate — do not proceed to commit.

---

### Task 5: Update `docs/todo.md`

**Files:**
- Modify: `docs/todo.md`

Find this line:
```markdown
- [ ] Diff old vs. new dependency lists in `Memo::force_recompute` instead of full replacement
```

Replace with:
```markdown
- [x] Diff old vs. new dependency lists in `Memo::force_recompute` instead of full replacement
```

---

### Task 6: Commit

```bash
cd /home/antisatori/ghq/github.com/dowdiness/incr && git add memo.mbt runtime.mbt memo_dep_diff_wbtest.mbt docs/todo.md && git commit -m "$(cat <<'EOF'
perf: diff dep lists in force_recompute to skip durability rescan

Skip compute_durability when the dependency set is stable (common case).
Reuses the HashSet already built by ActiveQuery — zero extra allocation.
Adds Phase 4 comments marking where subscriber unsubscription will go.

Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>
EOF
)"
```
