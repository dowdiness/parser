// Generated using `moon info`, DON'T EDIT IT
package "dowdiness/incr/internal"

import {
  "dowdiness/incr/types",
  "moonbitlang/core/debug",
}

// Values

// Errors
pub suberror CycleError {
  CycleDetected(@types.CellId, Array[@types.CellId])
}
pub fn CycleError::cell(Self) -> @types.CellId
pub fn CycleError::format_path(Self, Runtime) -> String
pub fn CycleError::path(Self) -> Array[@types.CellId]

// Types and methods
pub(all) struct CellInfo {
  label : String?
  id : @types.CellId
  changed_at : @types.Revision
  verified_at : @types.Revision
  durability : @types.Durability
  dependencies : Array[@types.CellId]
  subscribers : Array[@types.CellId]
}

pub(all) struct Memo[T] {
  // private fields

  fn[T : Eq] new(Runtime, () -> T, label? : String) -> Memo[T]
}
pub fn[T] Memo::changed_at(Self[T]) -> @types.Revision
pub fn[T] Memo::clear_on_change(Self[T]) -> Unit
pub fn[T] Memo::dependencies(Self[T]) -> Array[@types.CellId]
pub fn[T : Eq] Memo::get(Self[T]) -> T
pub fn[T : Eq] Memo::get_result(Self[T]) -> Result[T, CycleError]
pub fn[T] Memo::id(Self[T]) -> @types.CellId
pub fn[T] Memo::is_up_to_date(Self[T]) -> Bool
pub fn[T : Eq] Memo::new(Runtime, () -> T, label? : String) -> Self[T]
pub fn[T] Memo::on_change(Self[T], (T) -> Unit) -> Unit
pub fn[T] Memo::verified_at(Self[T]) -> @types.Revision
pub impl[T : @debug.Debug] @debug.Debug for Memo[T]

pub(all) struct MemoMap[K, V] {
  // private fields

  fn[K, V] new(Runtime, (K) -> V, label? : String) -> MemoMap[K, V]
}
pub fn[K : Hash + Eq, V] MemoMap::contains(Self[K, V], K) -> Bool
pub fn[K : Hash + Eq, V : Eq] MemoMap::get(Self[K, V], K) -> V
pub fn[K : Hash + Eq, V : Eq] MemoMap::get_result(Self[K, V], K) -> Result[V, CycleError]
pub fn[K, V] MemoMap::length(Self[K, V]) -> Int
pub fn[K, V] MemoMap::new(Runtime, (K) -> V, label? : String) -> Self[K, V]

pub(all) struct Runtime {
  // private fields

  fn new(on_change? : () -> Unit) -> Runtime
}
pub fn Runtime::batch(Self, () -> Unit) -> Unit
pub fn Runtime::cell_info(Self, @types.CellId) -> CellInfo?
pub fn Runtime::clear_on_change(Self) -> Unit
pub fn Runtime::dependents(Self, @types.CellId) -> Array[@types.CellId]
pub fn Runtime::new(on_change? : () -> Unit) -> Self
pub fn Runtime::set_on_change(Self, () -> Unit) -> Unit

pub(all) struct Signal[T] {
  // private fields

  fn[T] new(Runtime, T, durability? : @types.Durability, label? : String) -> Signal[T]
}
pub fn[T] Signal::clear_on_change(Self[T]) -> Unit
pub fn[T] Signal::durability(Self[T]) -> @types.Durability
pub fn[T] Signal::get(Self[T]) -> T
pub fn[T] Signal::get_result(Self[T]) -> Result[T, CycleError]
pub fn[T] Signal::id(Self[T]) -> @types.CellId
pub fn[T] Signal::is_up_to_date(Self[T]) -> Bool
pub fn[T] Signal::new(Runtime, T, durability? : @types.Durability, label? : String) -> Self[T]
pub fn[T] Signal::on_change(Self[T], (T) -> Unit) -> Unit
pub fn[T : Eq] Signal::set(Self[T], T) -> Unit
pub fn[T] Signal::set_unconditional(Self[T], T) -> Unit
pub impl[T : @debug.Debug] @debug.Debug for Signal[T]

pub(all) struct TrackedCell[T] {
  // private fields

  fn[T] new(Runtime, T, durability? : @types.Durability, label? : String) -> TrackedCell[T]
}
pub fn[T] TrackedCell::as_signal(Self[T]) -> Signal[T]
pub fn[T] TrackedCell::clear_on_change(Self[T]) -> Unit
pub fn[T] TrackedCell::durability(Self[T]) -> @types.Durability
pub fn[T] TrackedCell::get(Self[T]) -> T
pub fn[T] TrackedCell::get_result(Self[T]) -> Result[T, CycleError]
pub fn[T] TrackedCell::id(Self[T]) -> @types.CellId
pub fn[T] TrackedCell::is_up_to_date(Self[T]) -> Bool
pub fn[T] TrackedCell::new(Runtime, T, durability? : @types.Durability, label? : String) -> Self[T]
pub fn[T] TrackedCell::on_change(Self[T], (T) -> Unit) -> Unit
pub fn[T : Eq] TrackedCell::set(Self[T], T) -> Unit
pub fn[T] TrackedCell::set_unconditional(Self[T], T) -> Unit
pub impl[T : @debug.Debug] @debug.Debug for TrackedCell[T]

// Type aliases

// Traits

