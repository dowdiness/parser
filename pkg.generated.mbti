// Generated using `moon info`, DON'T EDIT IT
package "dowdiness/incr"

import {
  "dowdiness/incr/internal",
  "dowdiness/incr/types",
}

// Values
pub const DURABILITY_COUNT : Int = 3

pub fn[Db : IncrDb] batch(Db, () -> Unit raise?) -> Unit raise?

pub fn[Db : IncrDb] batch_result(Db, () -> Unit raise?) -> Result[Unit, Error]

pub fn[Db : IncrDb, T : Eq] create_memo(Db, () -> T, label? : String) -> @internal.Memo[T]

pub fn[Db : IncrDb, K, V] create_memo_map(Db, (K) -> V, label? : String) -> @internal.MemoMap[K, V]

pub fn[Db : IncrDb, T] create_signal(Db, T, durability? : @types.Durability, label? : String) -> @internal.Signal[T]

pub fn[Db : IncrDb, T] create_tracked_cell(Db, T, durability? : @types.Durability, label? : String) -> @internal.TrackedCell[T]

pub fn[T : Trackable] gc_tracked(@internal.Runtime, T) -> Unit

// Errors

// Types and methods

// Type aliases
pub using @types {type CellId}

pub using @internal {type CellInfo}

pub using @internal {type CycleError}

pub using @types {type Durability}

pub using @internal {type Memo}

pub using @internal {type MemoMap}

pub using @types {type Revision}

pub using @internal {type Runtime}

pub using @internal {type Signal}

pub using @internal {type TrackedCell}

// Traits
pub(open) trait IncrDb {
  runtime(Self) -> @internal.Runtime
}

pub(open) trait Readable {
  is_up_to_date(Self) -> Bool
}
pub impl[T] Readable for @internal.Memo[T]
pub impl[T] Readable for @internal.Signal[T]
pub impl[T] Readable for @internal.TrackedCell[T]

pub(open) trait Trackable {
  cell_ids(Self) -> Array[@types.CellId]
}

