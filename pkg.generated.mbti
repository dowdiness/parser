// Generated using `moon info`, DON'T EDIT IT
package "dowdiness/parser"

import {
  "moonbitlang/core/hashmap",
  "moonbitlang/core/json",
}

// Values
pub fn ast_to_crdt(TermNode) -> CRDTNode

pub fn build_tree(Array[ParseEvent]) -> GreenNode

pub fn collect_errors(TermNode) -> Array[String]

pub fn crdt_to_source(CRDTNode) -> String

pub fn green_to_term(GreenNode) -> Term

pub fn green_to_term_node(GreenNode, Int, Ref[Int]) -> TermNode

pub fn has_errors(TermNode) -> Bool

pub fn node_to_term(TermNode) -> Term

pub fn parse(String) -> Term raise

pub fn parse_green(String) -> GreenNode raise

pub fn parse_green_to_term_node(String) -> TermNode raise

pub fn parse_tree(String) -> TermNode raise

pub fn parse_tree_from_tokens(Array[TokenInfo]) -> TermNode raise

pub fn parse_with_error_recovery(String) -> (TermNode, Array[String])

pub fn parse_with_error_recovery_tokens(Array[TokenInfo]) -> (TermNode, Array[String])

pub fn print_crdt_tree(CRDTNode, Int) -> String

pub fn print_term(Term) -> String

pub fn print_term_node(TermNode) -> String

pub fn print_token(Token) -> String

pub fn print_token_info(TokenInfo) -> String

pub fn print_token_infos(Array[TokenInfo]) -> String

pub fn print_tokens(Array[Token]) -> String

pub fn term_node_to_dot(TermNode) -> String

pub fn tokenize(String) -> Array[TokenInfo] raise TokenizationError

pub fn tokenize_range(String, Int, Int) -> Array[TokenInfo] raise TokenizationError

// Errors
pub suberror ParseError {
  ParseError(String, Token)
}

pub suberror TokenizationError {
  TokenizationError(String)
}

// Types and methods
pub(all) enum Bop {
  Plus
  Minus
}
pub impl Eq for Bop
pub impl Show for Bop
pub impl ToJson for Bop
pub impl @json.FromJson for Bop

pub struct CRDTNode {
  node_type : String
  text_value : String
  attributes : @hashmap.HashMap[String, String]
  children : Array[CRDTNode]
}
pub fn CRDTNode::new(String, String, @hashmap.HashMap[String, String], Array[Self]) -> Self

pub struct DamageTracker {
  damaged_ranges : Array[Range]
}
pub fn DamageTracker::add_range(Self, Range) -> Unit
pub fn DamageTracker::empty() -> Self
pub fn DamageTracker::expand_for_node(Self, Int, Int) -> Unit
pub fn DamageTracker::expand_for_tree(Self, TermNode) -> Unit
pub fn DamageTracker::is_damaged(Self, Range) -> Bool
pub fn DamageTracker::is_position_damaged(Self, Int) -> Bool
pub fn DamageTracker::new(Edit) -> Self
pub fn DamageTracker::range(Self) -> Range
pub fn DamageTracker::stats(Self) -> String

pub struct Edit {
  start : Int
  old_end : Int
  new_end : Int
}
pub fn Edit::affects_position(Self, Int) -> Bool
pub fn Edit::apply_to_position(Self, Int) -> Int
pub fn Edit::delete(Int, Int) -> Self
pub fn Edit::deleted_length(Self) -> Int
pub fn Edit::delta(Self) -> Int
pub fn Edit::insert(Int, Int) -> Self
pub fn Edit::inserted_length(Self) -> Int
pub fn Edit::new(Int, Int, Int) -> Self
pub fn Edit::overlaps_range(Self, Int, Int) -> Bool
pub fn Edit::replace(Int, Int, Int) -> Self
pub fn Edit::to_string(Self) -> String
pub impl Eq for Edit
pub impl Show for Edit

pub struct EventBuffer {
  events : Array[ParseEvent]
}
pub fn EventBuffer::mark(Self) -> Int
pub fn EventBuffer::new() -> Self
pub fn EventBuffer::push(Self, ParseEvent) -> Unit
pub fn EventBuffer::start_at(Self, Int, SyntaxKind) -> Unit

pub enum GreenElement {
  Token(GreenToken)
  Node(GreenNode)
}
pub fn GreenElement::kind(Self) -> SyntaxKind
pub fn GreenElement::text_len(Self) -> Int
pub impl Eq for GreenElement
pub impl Show for GreenElement

pub struct GreenNode {
  kind : SyntaxKind
  children : Array[GreenElement]
  text_len : Int
}
pub fn GreenNode::kind(Self) -> SyntaxKind
pub fn GreenNode::new(SyntaxKind, Array[GreenElement]) -> Self
pub impl Eq for GreenNode
pub impl Show for GreenNode

pub struct GreenToken {
  kind : SyntaxKind
  text : String
}
pub fn GreenToken::new(SyntaxKind, String) -> Self
pub fn GreenToken::text_len(Self) -> Int
pub impl Eq for GreenToken
pub impl Show for GreenToken

pub struct IncrementalParser {
  mut source : String
  mut tree : TermNode?
  mut token_buffer : TokenBuffer?
}
pub fn IncrementalParser::edit(Self, Edit, String) -> TermNode
pub fn IncrementalParser::get_source(Self) -> String
pub fn IncrementalParser::get_tree(Self) -> TermNode?
pub fn IncrementalParser::new(String) -> Self
pub fn IncrementalParser::parse(Self) -> TermNode
pub fn IncrementalParser::stats(Self) -> String

pub enum ParseEvent {
  StartNode(SyntaxKind)
  FinishNode
  Token(SyntaxKind, String)
  Tombstone
}
pub impl Eq for ParseEvent
pub impl Show for ParseEvent

pub struct ParsedDocument {
  mut source : String
  parser : IncrementalParser
  mut crdt_tree : CRDTNode?
}
pub fn ParsedDocument::edit(Self, Edit, String) -> Unit
pub fn ParsedDocument::get_crdt_tree(Self) -> CRDTNode?
pub fn ParsedDocument::get_source(Self) -> String
pub fn ParsedDocument::new(String) -> Self
pub fn ParsedDocument::parse(Self) -> Unit
pub fn ParsedDocument::reconstruct_source(Self) -> String

pub struct Range {
  start : Int
  end : Int
}
pub fn Range::contains(Self, Int) -> Bool
pub fn Range::length(Self) -> Int
pub fn Range::merge(Self, Self) -> Self
pub fn Range::minimum_by_length(Self, Self) -> Self
pub fn Range::new(Int, Int) -> Self
pub fn Range::overlaps(Self, Self) -> Bool
pub impl Compare for Range
pub impl Eq for Range
pub impl Hash for Range
pub impl Show for Range

pub struct RedNode {
  green : GreenNode
  parent : RedNode?
  offset : Int
}
pub fn RedNode::children(Self) -> Array[Self]
pub fn RedNode::end(Self) -> Int
pub fn RedNode::from_green(GreenNode) -> Self
pub fn RedNode::kind(Self) -> SyntaxKind
pub fn RedNode::new(GreenNode, Self?, Int) -> Self
pub fn RedNode::start(Self) -> Int

pub enum SyntaxKind {
  LambdaToken
  DotToken
  LeftParenToken
  RightParenToken
  PlusToken
  MinusToken
  IfKeyword
  ThenKeyword
  ElseKeyword
  IdentToken
  IntToken
  WhitespaceToken
  ErrorToken
  EofToken
  LambdaExpr
  AppExpr
  BinaryExpr
  IfExpr
  ParenExpr
  IntLiteral
  VarRef
  ErrorNode
  SourceFile
}
pub fn SyntaxKind::is_token(Self) -> Bool
pub impl Eq for SyntaxKind
pub impl Show for SyntaxKind

pub(all) enum Term {
  Int(Int)
  Var(String)
  Lam(String, Term)
  App(Term, Term)
  Bop(Bop, Term, Term)
  If(Term, Term, Term)
}
pub impl Eq for Term
pub impl Show for Term

pub(all) enum TermKind {
  Int(Int)
  Var(String)
  Lam(String)
  App
  Bop(Bop)
  If
  Error(String)
}
pub impl Show for TermKind
pub impl ToJson for TermKind
pub impl @json.FromJson for TermKind

pub struct TermNode {
  kind : TermKind
  start : Int
  end : Int
  node_id : Int
  children : Array[TermNode]
}
pub fn TermNode::error(String, Int, Int) -> Self
pub fn TermNode::new(TermKind, Int, Int, Int, Array[Self]) -> Self
pub impl Show for TermNode
pub impl ToJson for TermNode
pub impl @json.FromJson for TermNode

pub enum Token {
  Lambda
  Dot
  LeftParen
  RightParen
  Plus
  Minus
  If
  Then
  Else
  Identifier(String)
  Integer(Int)
  EOF
}
pub impl Eq for Token
pub impl Show for Token

pub struct TokenBuffer {
  mut tokens : Array[TokenInfo]
  mut source : String
  mut version : Int
}
pub fn TokenBuffer::get_source(Self) -> String
pub fn TokenBuffer::get_tokens(Self) -> Array[TokenInfo]
pub fn TokenBuffer::get_version(Self) -> Int
pub fn TokenBuffer::new(String) -> Self raise TokenizationError
pub fn TokenBuffer::update(Self, Edit, String) -> Array[TokenInfo] raise TokenizationError

pub struct TokenInfo {
  token : Token
  start : Int
  end : Int
}
pub fn TokenInfo::new(Token, Int, Int) -> Self
pub impl Eq for TokenInfo
pub impl Show for TokenInfo

// Type aliases
pub type VarName = String

// Traits

