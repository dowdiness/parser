// Generated using `moon info`, DON'T EDIT IT
package "dowdiness/parser/lambda"

import {
  "dowdiness/parser/ast",
  "dowdiness/parser/core",
  "dowdiness/parser/incremental",
  "dowdiness/parser/pipeline",
  "dowdiness/parser/syntax",
  "dowdiness/parser/token",
  "dowdiness/seam",
}

// Values
pub fn collect_errors(@ast.AstNode) -> Array[String]

pub fn cst_to_ast_node(@seam.CstNode, Int, Ref[Int]) -> @ast.AstNode

pub fn cst_to_term(@seam.CstNode) -> @ast.Term

pub fn has_errors(@ast.AstNode) -> Bool

pub fn lambda_incremental_language() -> @incremental.IncrementalLanguage[@ast.AstNode]

pub fn lambda_language() -> @pipeline.Language[@ast.AstNode]

pub fn make_reuse_cursor(@seam.CstNode, Int, Int, Array[@core.TokenInfo[@token.Token]]) -> @core.ReuseCursor[@token.Token, @syntax.SyntaxKind]

pub fn parse(String) -> @ast.Term raise

pub fn parse_cst(String) -> @seam.CstNode raise

pub fn parse_cst_recover(String, interner? : @seam.Interner?, node_interner? : @seam.NodeInterner?) -> (@seam.CstNode, Array[@core.Diagnostic[@token.Token]]) raise @core.LexError

pub fn parse_cst_recover_with_tokens(String, Array[@core.TokenInfo[@token.Token]], @core.ReuseCursor[@token.Token, @syntax.SyntaxKind]?, prev_diagnostics? : Array[@core.Diagnostic[@token.Token]]?, interner? : @seam.Interner?, node_interner? : @seam.NodeInterner?) -> (@seam.CstNode, Array[@core.Diagnostic[@token.Token]], Int)

pub fn parse_cst_to_ast_node(String) -> @ast.AstNode raise

pub fn parse_cst_with_cursor(String, Array[@core.TokenInfo[@token.Token]], @core.ReuseCursor[@token.Token, @syntax.SyntaxKind], prev_diagnostics? : Array[@core.Diagnostic[@token.Token]]?) -> (@seam.CstNode, Array[@core.Diagnostic[@token.Token]], Int)

pub fn parse_tree(String) -> @ast.AstNode raise

pub fn parse_with_error_recovery(String) -> (@ast.AstNode, Array[String])

pub fn syntax_node_to_ast_node(@seam.SyntaxNode, Ref[Int]) -> @ast.AstNode

pub fn to_dot(@ast.AstNode) -> String

// Errors
pub suberror ParseError {
  ParseError(String, @token.Token)
}

// Types and methods
pub struct LambdaIncrementalParser {
  // private fields
}
pub fn LambdaIncrementalParser::edit(Self, @core.Edit, String) -> @ast.AstNode
pub fn LambdaIncrementalParser::get_last_reuse_count(Self) -> Int
pub fn LambdaIncrementalParser::get_source(Self) -> String
pub fn LambdaIncrementalParser::get_tree(Self) -> @ast.AstNode?
pub fn LambdaIncrementalParser::interner_clear(Self) -> Unit
pub fn LambdaIncrementalParser::interner_size(Self) -> Int
pub fn LambdaIncrementalParser::new(String) -> Self
pub fn LambdaIncrementalParser::node_interner_size(Self) -> Int
pub fn LambdaIncrementalParser::parse(Self) -> @ast.AstNode
pub fn LambdaIncrementalParser::stats(Self) -> String

pub struct LambdaLanguage {
}
pub impl @pipeline.Parseable for LambdaLanguage

pub struct LambdaParserDb {
  // private fields
}
pub fn LambdaParserDb::cst(Self) -> @pipeline.CstStage
pub fn LambdaParserDb::diagnostics(Self) -> Array[String]
pub fn LambdaParserDb::new(String) -> Self
pub fn LambdaParserDb::set_source(Self, String) -> Unit
pub fn LambdaParserDb::term(Self) -> @ast.AstNode

// Type aliases

// Traits

