// Generated using `moon info`, DON'T EDIT IT
package "dowdiness/parser/core"

import {
  "dowdiness/seam",
}

// Values
pub fn[T, K] parse_with(String, LanguageSpec[T, K], (String) -> Array[TokenInfo[T]], (ParserContext[T, K]) -> Unit) -> (@seam.CstNode, Array[Diagnostic[T]])

// Errors

// Types and methods
type CursorFrame

pub struct Diagnostic[T] {
  message : String
  start : Int
  end : Int
  got_token : T
}
pub impl[T : Show] Show for Diagnostic[T]

pub(all) struct Edit {
  start : Int
  old_end : Int
  new_end : Int
}
pub fn Edit::affects_position(Self, Int) -> Bool
pub fn Edit::apply_to_position(Self, Int) -> Int
pub fn Edit::delete(Int, Int) -> Self
pub fn Edit::deleted_length(Self) -> Int
pub fn Edit::delta(Self) -> Int
pub fn Edit::insert(Int, Int) -> Self
pub fn Edit::inserted_length(Self) -> Int
pub fn Edit::new(Int, Int, Int) -> Self
pub fn Edit::overlaps_range(Self, Int, Int) -> Bool
pub fn Edit::replace(Int, Int, Int) -> Self
pub fn Edit::to_string(Self) -> String
pub impl Eq for Edit
pub impl Show for Edit

pub struct LanguageSpec[T, K] {
  kind_to_raw : (K) -> @seam.RawKind
  token_is_eof : (T) -> Bool
  token_is_trivia : (T) -> Bool
  tokens_equal : (T, T) -> Bool
  print_token : (T) -> String
  whitespace_kind : K
  error_kind : K
  root_kind : K
  eof_token : T
  raw_is_trivia : (@seam.RawKind) -> Bool
  raw_is_error : (@seam.RawKind) -> Bool
  cst_token_matches : (@seam.RawKind, String, T) -> Bool
}
pub fn[T, K] LanguageSpec::new((K) -> @seam.RawKind, (T) -> Bool, (T) -> Bool, (T, T) -> Bool, (T) -> String, K, K, K, T, raw_is_trivia? : (@seam.RawKind) -> Bool, raw_is_error? : (@seam.RawKind) -> Bool, cst_token_matches? : (@seam.RawKind, String, T) -> Bool) -> Self[T, K]

type OldToken
pub impl Compare for OldToken
pub impl Eq for OldToken
pub impl Show for OldToken

pub struct ParserContext[T, K] {
  spec : LanguageSpec[T, K]
  token_count : Int
  get_token : (Int) -> T
  get_start : (Int) -> Int
  get_end : (Int) -> Int
  source : String
  mut position : Int
  events : @seam.EventBuffer
  errors : Array[Diagnostic[T]]
  mut error_count : Int
  mut open_nodes : Int
  mut reuse_cursor : ReuseCursor[T, K]?
  mut reuse_diagnostics : Array[Diagnostic[T]]?
  mut reuse_count : Int
}
pub fn[T, K] ParserContext::at(Self[T, K], T) -> Bool
pub fn[T, K] ParserContext::at_eof(Self[T, K]) -> Bool
pub fn[T, K] ParserContext::bump_error(Self[T, K]) -> Unit
pub fn[T, K] ParserContext::emit_error_placeholder(Self[T, K]) -> Unit
pub fn[T, K] ParserContext::emit_token(Self[T, K], K) -> Unit
pub fn[T, K] ParserContext::emit_zero_width(Self[T, K], K) -> Unit
pub fn[T, K] ParserContext::error(Self[T, K], String) -> Unit
pub fn[T, K] ParserContext::finish_node(Self[T, K]) -> Unit
pub fn[T, K] ParserContext::flush_trivia(Self[T, K]) -> Unit
pub fn[T, K] ParserContext::mark(Self[T, K]) -> Int
pub fn[T, K] ParserContext::new(Array[TokenInfo[T]], String, LanguageSpec[T, K]) -> Self[T, K]
pub fn[T, K] ParserContext::new_indexed(Int, (Int) -> T, (Int) -> Int, (Int) -> Int, String, LanguageSpec[T, K]) -> Self[T, K]
pub fn[T, K] ParserContext::node(Self[T, K], K, () -> Unit) -> Unit
pub fn[T, K] ParserContext::peek(Self[T, K]) -> T
pub fn[T, K] ParserContext::peek_info(Self[T, K]) -> TokenInfo[T]
pub fn[T, K] ParserContext::set_reuse_cursor(Self[T, K], ReuseCursor[T, K]) -> Unit
pub fn[T, K] ParserContext::set_reuse_diagnostics(Self[T, K], Array[Diagnostic[T]]) -> Unit
pub fn[T, K] ParserContext::start_at(Self[T, K], Int, K) -> Unit
pub fn[T, K] ParserContext::start_node(Self[T, K], K) -> Unit
pub fn[T, K] ParserContext::token_text(Self[T, K], TokenInfo[T]) -> String
pub fn[T, K] ParserContext::wrap_at(Self[T, K], Int, K, () -> Unit) -> Unit

pub(all) struct Range {
  start : Int
  end : Int
}
pub fn Range::contains(Self, Int) -> Bool
pub fn Range::length(Self) -> Int
pub fn Range::merge(Self, Self) -> Self
pub fn Range::minimum_by_length(Self, Self) -> Self
pub fn Range::new(Int, Int) -> Self
pub fn Range::overlaps(Self, Self) -> Bool
pub impl Compare for Range
pub impl Eq for Range
pub impl Hash for Range
pub impl Show for Range

pub struct ReuseCursor[T, K] {
  stack : Array[CursorFrame]
  mut current_offset : Int
  damage_start : Int
  damage_end : Int
  old_tokens : Array[OldToken]
  reuse_globally_disabled : Bool
  token_count : Int
  get_token : (Int) -> T
  get_start : (Int) -> Int
  spec : LanguageSpec[T, K]
}
pub fn[T, K] ReuseCursor::advance_past(Self[T, K], @seam.CstNode) -> Unit
pub fn[T, K] ReuseCursor::is_reuse_disabled(Self[T, K]) -> Bool
pub fn[T, K] ReuseCursor::new(@seam.CstNode, Int, Int, Int, (Int) -> T, (Int) -> Int, LanguageSpec[T, K]) -> Self[T, K]
pub fn[T, K] ReuseCursor::next_sibling_has_error(Self[T, K]) -> Bool
pub fn[T, K] ReuseCursor::try_reuse(Self[T, K], @seam.RawKind, Int, Int) -> @seam.CstNode?

pub struct TokenInfo[T] {
  token : T
  start : Int
  end : Int
}
pub fn[T] TokenInfo::new(T, Int, Int) -> Self[T]
pub impl[T : Show] Show for TokenInfo[T]

// Type aliases

// Traits

