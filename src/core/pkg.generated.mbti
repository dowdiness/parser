// Generated using `moon info`, DON'T EDIT IT
package "dowdiness/parser/core"

import {
  "dowdiness/parser/green-tree",
}

// Values
pub fn[T, K] parse_with(String, LanguageSpec[T, K], (String) -> Array[TokenInfo[T]], (ParserContext[T, K]) -> Unit) -> (@green-tree.GreenNode, Array[Diagnostic])

// Errors

// Types and methods
pub struct Diagnostic {
  message : String
  start : Int
  end : Int
}
pub impl Show for Diagnostic

pub struct LanguageSpec[T, K] {
  kind_to_raw : (K) -> @green-tree.RawKind
  token_is_eof : (T) -> Bool
  token_is_trivia : (T) -> Bool
  tokens_equal : (T, T) -> Bool
  whitespace_kind : K
  error_kind : K
  root_kind : K
  eof_token : T
}
pub fn[T, K] LanguageSpec::new((K) -> @green-tree.RawKind, (T) -> Bool, (T) -> Bool, (T, T) -> Bool, K, K, K, T) -> Self[T, K]

pub struct ParserContext[T, K] {
  spec : LanguageSpec[T, K]
  tokens : Array[TokenInfo[T]]
  source : String
  mut position : Int
  events : @green-tree.EventBuffer
  errors : Array[Diagnostic]
  mut error_count : Int
  mut open_nodes : Int
}
pub fn[T, K] ParserContext::at(Self[T, K], T) -> Bool
pub fn[T, K] ParserContext::at_eof(Self[T, K]) -> Bool
pub fn[T, K] ParserContext::bump_error(Self[T, K]) -> Unit
pub fn[T, K] ParserContext::emit_token(Self[T, K], K) -> Unit
pub fn[T, K] ParserContext::error(Self[T, K], String) -> Unit
pub fn[T, K] ParserContext::finish_node(Self[T, K]) -> Unit
pub fn[T, K] ParserContext::flush_trivia(Self[T, K]) -> Unit
pub fn[T, K] ParserContext::mark(Self[T, K]) -> Int
pub fn[T, K] ParserContext::new(Array[TokenInfo[T]], String, LanguageSpec[T, K]) -> Self[T, K]
pub fn[T, K] ParserContext::peek(Self[T, K]) -> T
pub fn[T, K] ParserContext::peek_info(Self[T, K]) -> TokenInfo[T]
pub fn[T, K] ParserContext::start_at(Self[T, K], Int, K) -> Unit
pub fn[T, K] ParserContext::start_node(Self[T, K], K) -> Unit
pub fn[T, K] ParserContext::token_text(Self[T, K], TokenInfo[T]) -> String

type TestKind
pub impl Show for TestKind

type TestTok
pub impl Eq for TestTok
pub impl Show for TestTok

pub struct TokenInfo[T] {
  token : T
  start : Int
  end : Int
}
pub fn[T] TokenInfo::new(T, Int, Int) -> Self[T]
pub impl[T : Show] Show for TokenInfo[T]

// Type aliases

// Traits

