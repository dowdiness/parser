///|
/// Handle multiple children from SourceFile (main expression + error nodes).
fn convert_source_file_children(
  children : Array[@ast.AstNode],
  off : Int,
  counter : Ref[Int],
) -> @ast.AstNode {
  fn next_id() -> Int {
    let id = counter.val
    counter.val = id + 1
    id
  }

  if children.length() == 0 {
    return @ast.AstNode::error("Empty SourceFile", off, next_id())
  }
  if children.length() == 1 {
    return children[0]
  }
  // Multiple children: find the first non-error child as main, rest as error children
  let main_nodes : Array[@ast.AstNode] = []
  let error_nodes : Array[@ast.AstNode] = []
  for child in children {
    match child.kind {
      @ast.AstKind::Error(_) => error_nodes.push(child)
      _ => main_nodes.push(child)
    }
  }
  if main_nodes.length() > 0 {
    let m = main_nodes[0]
    // Attach any extra main nodes and error nodes as children
    let extra : Array[@ast.AstNode] = []
    for i = 1; i < main_nodes.length(); i = i + 1 {
      extra.push(main_nodes[i])
    }
    extra.append(error_nodes)
    if extra.length() > 0 {
      let all_children : Array[@ast.AstNode] = m.children.copy()
      all_children.append(extra)
      // Extend end to cover all children so the parent span is a superset
      let mut end = m.end
      for child in extra {
        if child.end > end {
          end = child.end
        }
      }
      @ast.AstNode::new(m.kind, m.start, end, next_id(), all_children)
    } else {
      m
    }
    // All children are errors â€” wrap them under a single error node
    // so none are discarded
  } else {
    let mut start = children[0].start
    let mut end = children[0].end
    for child in children {
      if child.start < start {
        start = child.start
      }
      if child.end > end {
        end = child.end
      }
    }
    @ast.AstNode::new(
      @ast.AstKind::Error("Syntax error"),
      start,
      end,
      next_id(),
      children,
    )
  }
}

///|
/// Convert a SyntaxNode to an AstNode. Uses SyntaxNode's offset-based position
/// computation instead of manual offset tracking.
fn convert_syntax_node(
  node : @seam.SyntaxNode,
  counter : Ref[Int],
) -> @ast.AstNode {
  fn next_id() -> Int {
    let id = counter.val
    counter.val = id + 1
    id
  }

  let ws = @syntax.WhitespaceToken.to_raw()
  match @syntax.SyntaxKind::from_raw(node.kind()) {
    @syntax.IntLiteral => {
      let text = node.find_token(@syntax.IntToken.to_raw()).map(fn(t) {
        t.text()
      }).unwrap_or("")
      let value = @strconv.parse_int(text) catch { _ => 0 }
      let (tight_start, tight_end) = node.tight_span(trivia_kind=Some(ws))
      @ast.AstNode::new(
        @ast.AstKind::Int(value),
        tight_start,
        tight_end,
        next_id(),
        [],
      )
    }
    @syntax.VarRef => {
      let name = node.find_token(@syntax.IdentToken.to_raw()).map(fn(t) {
        t.text()
      }).unwrap_or("")
      let (tight_start, tight_end) = node.tight_span(trivia_kind=Some(ws))
      @ast.AstNode::new(
        @ast.AstKind::Var(name),
        tight_start,
        tight_end,
        next_id(),
        [],
      )
    }
    @syntax.LambdaExpr => {
      let param = node.find_token(@syntax.IdentToken.to_raw()).map(fn(t) {
        t.text()
      }).unwrap_or("")
      let (tight_start, tight_end) = node.tight_span(trivia_kind=Some(ws))
      let syntax_children = node.children()
      for child in syntax_children {
        let body = convert_syntax_node(child, counter)
        return @ast.AstNode::new(
          @ast.AstKind::Lam(param),
          tight_start,
          body.end,
          next_id(),
          [body],
        )
      }
      @ast.AstNode::new(
        @ast.AstKind::Lam(param),
        tight_start,
        tight_end,
        next_id(),
        [],
      )
    }
    @syntax.AppExpr => {
      let children : Array[@ast.AstNode] = []
      let syntax_children = node.children()
      for child in syntax_children {
        children.push(convert_syntax_node(child, counter))
      }
      if children.length() >= 2 {
        let mut result = children[0]
        for i = 1; i < children.length(); i = i + 1 {
          result = @ast.AstNode::new(
            @ast.AstKind::App,
            result.start,
            children[i].end,
            next_id(),
            [result, children[i]],
          )
        }
        result
      } else if children.length() == 1 {
        children[0]
      } else {
        @ast.AstNode::error("Empty AppExpr", node.start(), next_id())
      }
    }
    @syntax.BinaryExpr => {
      let ops : Array[@ast.Bop] = []
      for elem in node.all_children() {
        match elem {
          @seam.SyntaxElement::Token(t) =>
            if t.kind() == @syntax.PlusToken.to_raw() {
              ops.push(@ast.Bop::Plus)
            } else if t.kind() == @syntax.MinusToken.to_raw() {
              ops.push(@ast.Bop::Minus)
            }
          _ => ()
        }
      }
      let children : Array[@ast.AstNode] = []
      let syntax_children = node.children()
      for child in syntax_children {
        children.push(convert_syntax_node(child, counter))
      }
      if children.length() >= 2 {
        let mut result = children[0]
        for i = 1; i < children.length(); i = i + 1 {
          let op = if i - 1 < ops.length() {
            ops[i - 1]
          } else {
            @ast.Bop::Plus
          }
          result = @ast.AstNode::new(
            @ast.AstKind::Bop(op),
            result.start,
            children[i].end,
            next_id(),
            [result, children[i]],
          )
        }
        result
      } else if children.length() == 1 {
        children[0]
      } else {
        @ast.AstNode::error("Empty BinaryExpr", node.start(), next_id())
      }
    }
    @syntax.IfExpr => {
      let (tight_start, _) = node.tight_span(trivia_kind=Some(ws))
      let children : Array[@ast.AstNode] = []
      let syntax_children = node.children()
      for child in syntax_children {
        children.push(convert_syntax_node(child, counter))
      }
      let if_end = if children.length() > 0 {
        children[children.length() - 1].end
      } else {
        node.end()
      }
      @ast.AstNode::new(
        @ast.AstKind::If,
        tight_start,
        if_end,
        next_id(),
        children,
      )
    }
    @syntax.ParenExpr => {
      let (tight_start, tight_end) = node.tight_span(trivia_kind=Some(ws))
      let syntax_children = node.children()
      for child in syntax_children {
        let inner = convert_syntax_node(child, counter)
        return @ast.AstNode::new(
          inner.kind,
          tight_start,
          tight_end,
          next_id(),
          inner.children,
        )
      }
      @ast.AstNode::error("Empty ParenExpr", node.start(), next_id())
    }
    @syntax.ErrorNode => {
      let (tight_start, tight_end) = node.tight_span(trivia_kind=Some(ws))
      let parts : Array[String] = []
      for t in node.tokens() {
        if t.kind() != ws && t.text() != "" {
          parts.push(t.text())
        }
      }
      let text = parts.join("")
      let msg = if text != "" {
        "Syntax error: " + text
      } else {
        "Syntax error"
      }
      @ast.AstNode::new(
        @ast.AstKind::Error(msg),
        tight_start,
        tight_end,
        next_id(),
        [],
      )
    }
    @syntax.SourceFile => {
      let syntax_children = node.children()
      let children : Array[@ast.AstNode] = []
      for child in syntax_children {
        children.push(convert_syntax_node(child, counter))
      }
      convert_source_file_children(children, node.start(), counter)
    }
    _ =>
      @ast.AstNode::error(
        "Unexpected node kind: " + node.kind().to_string(),
        node.start(),
        next_id(),
      )
  }
}

///|
/// Convert a SyntaxNode (position-aware CST facade) to an AstNode.
pub fn syntax_node_to_ast_node(
  node : @seam.SyntaxNode,
  node_id_counter : Ref[Int],
) -> @ast.AstNode {
  convert_syntax_node(node, node_id_counter)
}

///|
/// Convert a CstNode to an AstNode. Preserved for backward compatibility.
/// Internally creates a SyntaxNode and delegates to convert_syntax_node.
pub fn cst_to_ast_node(
  cst : @seam.CstNode,
  offset : Int,
  node_id_counter : Ref[Int],
) -> @ast.AstNode {
  let syntax = @seam.SyntaxNode::new(cst, None, offset)
  convert_syntax_node(syntax, node_id_counter)
}

///|
pub fn cst_to_term(cst : @seam.CstNode) -> @ast.Term {
  let node = cst_to_ast_node(cst, 0, Ref::new(0))
  @ast.node_to_term(node)
}

///|
pub fn parse_cst_to_ast_node(source : String) -> @ast.AstNode raise {
  let cst = parse_cst(source)
  cst_to_ast_node(cst, 0, Ref::new(0))
}
